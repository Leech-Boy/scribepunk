---
layout: default
title: "Why is there more than one Programming Language"
subtitle: "And unrepresentable numbers"
categories: substack
---

<!--excerpt-start-->
<p>While I was still in college as a computer science major, one of my friends asked me once, “why is there more than one programming language”. At the time I gave a brief explanation of how there are different tasks that programming languages are used for, and different tasks call for different languages. As with every other time someone has asked me a technical question in my field, I’ve thought about that question many times since then thinking about all the ways I could answer it. A few ideas stand out.</p>
<!--excerpt-end-->
<h1>A mathematical example</h1>
<p>One thought I’ve had since then is how to mathematically state the argument I made at the time. It goes like this:

We will begin with the mathematical notions of alphabets and languages. An alphabet is any set of symbols. It could be an actual alphabet like the English alphabet, the Phoenician alphabet, or the Cyrillic alphabet; it could be a set of numerals such as the Arabic numerals, the hexadecimal numerals (0-9 and A-F), or the RFC 4648 Base64 encoding numerals; or it could be any other set of symbols of any kind (i.e. it is an arbitrary set).

Once you have an alphabet, you can define a language on that alphabet. A language is a set of “well-formed” or “acceptable” sequences of alphabet characters. In other words, a language is a function that takes some sequence of alphabet symbols as input, and as output says whether that sequence is a statement in the language. For example, say your alphabet is the set of lowercase and uppercase English letters, the English punctuation marks, and the space that goes between words. One language you could define is the English language, which accepts a string of symbols if and only if that string of symbols is grammatically correct English. According to the English language “The quick brown fox jumped over the lazy dog.” is a well-formed statement, while “mj-cvq.ep;w” is not. We can create any language we want, however. For example, we can define “The Winner’s Language” as the language which accepts all strings that end in “w” or “W”, and no others. In this case the second of two strings listed above will be declared well-formed, but the first will not be.

Now suppose that we can assign meanings to statements in a language. For programming languages, the meaning of the statement is what the program does. There may be multiple ways to write equivalent programs, but each program must have a single meaning.

There are infinitely many things that a program can do, so it follows that some of those things can only be made to happen by writing an infinitely long program. This is an interesting fact, but not terribly important. The more important statement is that there are very many things that a reasonable person would want a program to do, therefore some of those things can only be made to happen by writing a very long program.

This is the rationale for that fact. Suppose you have a programming language whose alphabet has 10 characters. There are 10 different programs you can write with a single character, 100 programs you can write with 2 characters, 1,000 programs you can write with 3 characters, etc. Because there are so many different programs that a reasonable person might need, there must be some program which takes 100 characters to write, or 1,000 characters, or more. A good programming language is one in which you can write the most reasonable or important programs in the fewest characters.

This is one of the reasons that there are different programming languages. Different languages are designed with different ideas of what kinds of programs should be considered more reasonable or important. The C programming language assumes that programs which manipulate the specific ones and zeros of computer hardware are the important programs. These programs can be written in C without too many characters compared to other languages. The JavaScript programming language assumes that the programs that send and receive data over the web are the important programs. These programs can be written in JavaScript without too many characters compared to other languages.

If this is unclear, perhaps an analogy to natural language will help. It is a commonly cited “fact<sup>*</sup>” that the Inuit language has 50 different words for all the different kinds of snow, whereas English has relatively few. This makes sense, because English speakers do not encounter snow as much as native speakers of Eskaleut languages. For the same reason, programming languages are different. The C language has more ways to represent numbers than JavaScript because C programmers are more often concerned with the form of the numerical representation, whereas JavaScript developers typically only care about the value of the numbers.</p>
<h1>Detour</h1>
<p>This argument is not expressed as formally as I would like, but this has satisfied me, for now. An interesting fact can be deduced by a similar argument. Perhaps this fact will not appear to be related. If it does not that is only because I have not been abstract enough in my argument. Let the reader forgive me.

The interesting fact is that there are real numbers, that is numbers on the number line, that cannot be represented symbolically (with a finite number of characters). Every integer can be represented symbolically with a finite sequence of Arabic numerals. Likewise, every rational number (i.e. fractions or numbers with terminating or repeating decimal expansions) can be represented as a ratio of two integers. Because every integer can be represented with a finite number of characters, and the sum of two finite numbers is still finite, the rational numbers can be represented with a finite number of symbols, one of which is the division symbol.

The irrational numbers are harder to represent. Some like the square root of two, can be represented in a finite number of characters (the character 2 and the square root character). Others are trickier like π or ℇ. These numbers cannot be represented simply by other expressions; we have to make up new characters to represent them.

The startling fact is that you will never have enough characters. If you have a finite alphabet (i.e. there is a finite list of valid mathematical symbols) there will always be a number that you cannot represent with a finite number of characters. In fact, even if you had a countably infinite set of valid mathematical symbols, there will be numbers you cannot represent.</p>
<h1>Back to programming languages</h1>
<p>There are many other design decisions and priorities that must be considered when designing a programming language. In the early days of programming, programs were written on punch cards. Each punch card represented one line of code that was up to 80 characters long. This forced language designers to come up with ways to express operations too complex to be written in 80-character lines. Fortran for example, had line-continuation characters. If there were a line continuation character at the beginning of a line, that meant that that line was intended to be interpreted as a continuation of the previous line. This language feature is no longer necessary and so modern programming languages often don’t have it.

If a developer wants to describe their program as a collection of stateful objects which have operations applied to them, they should use an object oriented programming language. Contrariwise, if they wanted to describe their program fundamentally as a collection of operations which have data given to them, they should use a functional programming language. It would be absurd, if not definitionally impossible, to have a programming language that is simultaneously object oriented and functional.

There are countless other ways that languages can be different, whether memory management is done manually, through garbage collection, or through a borrow checker, whether the program code is interpreted during execution or compiled pre-execution, or whether the language’s symbols are delimited by whitespace or some other indicator. It’s impossible to have a language that does everything because many of the things that a programming language must do are mutually exclusive to each other. And that is why there is more than one programming language.</p>
<hr>
<p><sup>*</sup> This claim has been disputed with several different arguments, however similar languages present a more verifiable diversity of snow and ice words. “a lexicon of sea ice terminology in Nunavik (Appendix A of the collective work Siku: Knowing Our Ice, 2010) includes no fewer than 93 different words. These include general appellations such as siku, but also terms as specialized as qautsaulittuq, ice that breaks after its strength has been tested with a harpoon; kiviniq, a depression in shore ice caused by the weight of the water that passed over and accumulated on its surface during the tide; and iniruvik, ice that cracked because of tide changes and that the cold weather refroze.” (<a href=https://www.thecanadianencyclopedia.ca/en/article/inuktitut-words-for-snow-and-ice>https://www.thecanadianencyclopedia.ca/en/article/inuktitut-words-for-snow-and-ice</a>, Accessed Feb 10, 2026)</p>
